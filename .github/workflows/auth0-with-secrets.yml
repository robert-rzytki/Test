name: Auth0 migration [with secrets generation] - Dry Run 

on:
  workflow_dispatch:
    inputs:
      source_environment:
        description: 'Source Auth0 Environment (e.g., dev, stage, preprod)'
        required: true
        type: choice
        options:
          - dev
          - stage
          - preprod
          - prod
        default: dev
      target_environment:
        description: 'Target Auth0 Environment (e.g., dev, stage, preprod, prod)'
        required: true
        type: choice
        options:
          - dev
          - stage
          - preprod
          - prod
        default: stage
      allow_delete:
        description: 'Allow deletions in target tenant? (true/false) - For config generation'
        required: false
        type: boolean
        default: "false"

jobs:
  prepare-dry-run-config:
    runs-on: ubuntu-latest
    outputs:
      source_env_name: ${{ steps.prepare_env_names.outputs.source_env_name }}
      target_env_name: ${{ steps.prepare_env_names.outputs.target_env_name }}

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'

      - name: Install Auth0 Deploy CLI, jq, and Node.js Dependencies
        run: |
          npm install -g auth0-deploy-cli
          sudo apt-get update && sudo apt-get install -y jq
          npm install js-yaml # Install js-yaml for Node.js script to handle YAML

      - name: Prepare Environment Names
        id: prepare_env_names
        run: |
          SOURCE_ENV_NAME="${{ github.event.inputs.source_environment }}"
          TARGET_ENV_NAME="${{ github.event.inputs.target_environment }}"
          echo "source_env_name_upper=$(echo "$SOURCE_ENV_NAME" | tr '[:lower:]' '[:upper:]')" >> $GITHUB_ENV
          echo "target_env_name_upper=$(echo "$TARGET_ENV_NAME" | tr '[:lower:]' '[:upper:]')" >> $GITHUB_ENV
          echo "source_env_name=$SOURCE_ENV_NAME" >> $GITHUB_OUTPUT
          echo "target_env_name=$TARGET_ENV_NAME" >> $GITHUB_OUTPUT

      - name: Set Source Auth0 Credentials for Export
        run: |
          echo "AUTH0_DOMAIN_CURRENT=${{ secrets[format('{0}_AUTH0_DOMAIN', env.source_env_name_upper)] }}" >> $GITHUB_ENV
          echo "AUTH0_CLIENT_ID_CURRENT=${{ secrets[format('{0}_AUTH0_CLIENT_ID', env.source_env_name_upper)] }}" >> $GITHUB_ENV
          echo "AUTH0_CLIENT_SECRET_CURRENT=${{ secrets[format('{0}_AUTH0_CLIENT_SECRET', env.source_env_name_upper)] }}" >> $GITHUB_ENV

      - name: Export Configuration from Source Tenant
        run: |
          # Define the path to the source environment's config.json
          SOURCE_CONFIG_PATH="Auth0/${{ github.event.inputs.source_environment }}/config.json"
          
          echo "Validating $SOURCE_CONFIG_PATH before using it for export config generation..."
          if jq empty "$SOURCE_CONFIG_PATH" > /dev/null 2>&1; then
            echo "$SOURCE_CONFIG_PATH is valid JSON."
          else
            echo "Error: $SOURCE_CONFIG_PATH is NOT valid JSON. Please check its content."
            cat "$SOURCE_CONFIG_PATH" # Print content for debugging
            exit 1
          fi

          # Use the source_config_path for the jq command
          jq \
          --arg domain "$AUTH0_DOMAIN_CURRENT" \
          --arg client_id "$AUTH0_CLIENT_ID_CURRENT" \
          --arg client_secret "$AUTH0_CLIENT_SECRET_CURRENT" \
          '.AUTH0_DOMAIN = $domain | .AUTH0_CLIENT_ID = $client_id | .AUTH0_CLIENT_SECRET = $client_secret | .AUTH0_ALLOW_DELETE = false' \
          "$SOURCE_CONFIG_PATH" > temp_export_config.json

          echo "Exporting from $AUTH0_DOMAIN_CURRENT..."
          a0deploy export --config_file temp_export_config.json --format yaml --output_folder ./auth0_export_source
        env:
          AUTH0_DOMAIN_CURRENT: ${{ env.AUTH0_DOMAIN_CURRENT }}
          AUTH0_CLIENT_ID_CURRENT: ${{ env.AUTH0_CLIENT_ID_CURRENT }}
          AUTH0_CLIENT_SECRET_CURRENT: ${{ env.AUTH0_CLIENT_SECRET_CURRENT }}

      - name: Archive Original Exported Configuration
        uses: actions/upload-artifact@v4
        with:
          name: original-export-from-${{ github.event.inputs.source_environment }}
          path: ./auth0_export_source

      - name: Prepare Import Config File with Conditional Keyword Mappings
        id: prepare_import_config
        run: |
          set -e
          set -x
      
          # Define the path to the target environment's config.json
          TARGET_CONFIG_PATH="Auth0/${{ github.event.inputs.target_environment }}/config.json"

          echo "Validating $TARGET_CONFIG_PATH before use..."
          if jq empty "$TARGET_CONFIG_PATH" > /dev/null 2>&1; then
            echo "$TARGET_CONFIG_PATH is valid JSON."
          else
            echo "Invalid JSON in $TARGET_CONFIG_PATH"
            exit 1
          fi
          echo "--- Content of $TARGET_CONFIG_PATH being used by jq ---"
          cat "$TARGET_CONFIG_PATH"
          echo "----------------------------------------------"

          TARGET_DOMAIN_VALUE="${{ secrets[format('{0}_AUTH0_DOMAIN', env.target_env_name_upper)] }}"
          TARGET_CLIENT_ID_VALUE="${{ secrets[format('{0}_AUTH0_CLIENT_ID', env.target_env_name_upper)] }}"
          TARGET_CLIENT_SECRET_VALUE="${{ secrets[format('{0}_AUTH0_CLIENT_SECRET', env.target_env_name_upper)] }}"
          SOURCE_ENV_NAME="${{ github.event.inputs.source_environment }}"
          TARGET_ENV_NAME="${{ github.event.inputs.target_environment }}"
          
          # Convert boolean to string for bash compatibility
          ALLOW_DELETE_VALUE="${{ github.event.inputs.allow_delete }}"

          SOURCE_PREFIX_DOT="$SOURCE_ENV_NAME."
          SOURCE_PREFIX_BE="be$SOURCE_ENV_NAME."
          
          if [ "$TARGET_ENV_NAME" = "prod" ]; then
            TARGET_PREFIX_DOT="" 
            TARGET_PREFIX_BE="be." 
            TARGET_AUTH0_API_ENV_PART="prod" 
          else
            TARGET_PREFIX_DOT="$TARGET_ENV_NAME."
            TARGET_PREFIX_BE="be$TARGET_ENV_NAME."
            TARGET_AUTH0_API_ENV_PART="$TARGET_ENV_NAME" 
          fi

          SOURCE_AUTH0_API_ENV_PART="$SOURCE_ENV_NAME"
          if [ "$SOURCE_ENV_NAME" = "stage" ]; then
            SOURCE_AUTH0_API_ENV_PART="staging" 
          fi
          
          cat <<'JQ_PROGRAM_EOF' > temp_jq_program.jq
          .AUTH0_DOMAIN = $target_domain_jq |
          .AUTH0_CLIENT_ID = $target_client_id_jq |
          .AUTH0_CLIENT_SECRET = $target_client_secret_jq |
          .AUTH0_ALLOW_DELETE = $allow_delete_jq |
          .AUTH0_KEYWORD_REPLACE_MAPPINGS = {
              # Resource Server Identifiers & Client URLs (generic pattern)
              ("https://" + $source_prefix_dot_jq + "documentgenerator.bankenverband.de/") : ("https://" + $target_prefix_dot_jq + "documentgenerator.bankenverband.de/"),
              ("https://" + $source_prefix_dot_jq + "usermanagement.bankenverband.de/") : ("https://" + $target_prefix_dot_jq + "usermanagement.bankenverband.de/"),
              ("https://" + $source_prefix_be_jq + "portal2.bankenverband.de/") : ("https://" + $target_prefix_be_jq + "portal2.bankenverband.de/"),
              ("https://" + $source_prefix_be_jq + "elsa.bankenverband.de/") : ("https://" + $target_prefix_be_jq + "elsa.bankenverband.de/"),
              ("https://" + $source_prefix_dot_jq + "elsa.bankenverband.de") : ("https://" + $target_prefix_dot_jq + "elsa.bankenverband.de"), 
              
              # Client URLs base (paths are usually the same)
              ("https://" + $source_prefix_dot_jq + "portal2.bankenverband.de") : ("https://" + $target_prefix_dot_jq + "portal2.bankenverband.de"),
              
              # Auth0 Management API Audience
              ("https://bdb" + $source_auth0_api_env_part_jq + ".eu.auth0.com/api/v2/") : ("https://bdb" + $target_auth0_api_env_part_jq + ".eu.auth0.com/api/v2/"),

              # Special case for logo URL if it's consistently pointing to dev in source and should be target-specific
              ("https://dev.portal2.bankenverband.de/assets/logo.svg") : ("https://" + $target_prefix_dot_jq + "portal2.bankenverband.de/assets/logo.svg")
          }
          JQ_PROGRAM_EOF

          echo "Executing jq command..."
          # Use the target_config_path for the jq command
          jq \
            --arg target_domain_jq "$TARGET_DOMAIN_VALUE" \
            --arg target_client_id_jq "$TARGET_CLIENT_ID_VALUE" \
            --arg target_client_secret_jq "$TARGET_CLIENT_SECRET_VALUE" \
            --argjson allow_delete_jq "${{ github.event.inputs.allow_delete }}" \
            --arg source_env_name_jq "$SOURCE_ENV_NAME" \
            --arg target_env_name_jq "$TARGET_ENV_NAME" \
            --arg source_prefix_dot_jq "$SOURCE_PREFIX_DOT" \
            --arg source_prefix_be_jq "$SOURCE_PREFIX_BE" \
            --arg target_prefix_dot_jq "$TARGET_PREFIX_DOT" \
            --arg target_prefix_be_jq "$TARGET_PREFIX_BE" \
            --arg source_auth0_api_env_part_jq "$SOURCE_AUTH0_API_ENV_PART" \
            --arg target_auth0_api_env_part_jq "$TARGET_AUTH0_API_ENV_PART" \
            -f temp_jq_program.jq \
            "$TARGET_CONFIG_PATH" > temp_import_config.json
          
          JQ_EXIT_CODE=$?
          echo "jq command finished with exit code: $JQ_EXIT_CODE"
          if [ $JQ_EXIT_CODE -ne 0 ]; then
            echo "Error: jq command failed."
            # Attempt to get more detailed error from jq if possible
            jq \
              --arg target_domain_jq "$TARGET_DOMAIN_VALUE" \
              --arg target_client_id_jq "$TARGET_CLIENT_ID_VALUE" \
              --arg target_client_secret_jq "$TARGET_CLIENT_SECRET_VALUE" \
              --argjson allow_delete_jq "${{ github.event.inputs.allow_delete }}" \
              --arg source_env_name_jq "$SOURCE_ENV_NAME" \
              --arg target_env_name_jq "$TARGET_ENV_NAME" \
              --arg source_prefix_dot_jq "$SOURCE_PREFIX_DOT" \
              --arg source_prefix_be_jq "$SOURCE_PREFIX_BE" \
              --arg target_prefix_dot_jq "$TARGET_PREFIX_DOT" \
              --arg target_prefix_be_jq "$TARGET_PREFIX_BE" \
              --arg source_auth0_api_env_part_jq "$SOURCE_AUTH0_API_ENV_PART" \
              --arg target_auth0_api_env_part_jq "$TARGET_AUTH0_API_ENV_PART" \
              -f temp_jq_program.jq \
              "$TARGET_CONFIG_PATH" > /dev/null 2>&1 || echo "jq failed with detailed error above this line if any was printed to stderr"
            exit $JQ_EXIT_CODE
          fi

          rm temp_jq_program.jq 

          echo "--- Generated Import Config (temp_import_config.json) ---"
          cat temp_import_config.json
          echo "--- End Generated Import Config ---"
          set +x # Turn off command printing
          
      - name: Archive Generated Import Config File
        uses: actions/upload-artifact@v4
        with:
          name: import-config-for-${{ github.event.inputs.target_environment }}
          path: temp_import_config.json

      - name: Generate REDIRECT_SECRET
        id: generate_redirect_secret
        run: |
          REDIRECT_SECRET=$(openssl rand -hex 32)
          echo "REDIRECT_SECRET=$REDIRECT_SECRET" >> $GITHUB_OUTPUT

      - name: Simulate Transformation of tenant.yaml
        run: |
          echo "Simulating transformation of tenant.yaml..."
          
          # Create a temporary Node.js script file
          cat <<'NODE_SCRIPT_EOF' > transform_script.js
          const fs = require('fs');
          const path = require('path');
          const yaml = require('js-yaml'); // This library was installed in an earlier step

          const tenantYamlPath = path.join('./auth0_export_source', 'tenant.yaml');
          const importConfigPath = './temp_import_config.json';
          const outputTransformedTenantYamlPath = './transformed_tenant_preview.yaml';
          const redirectSecret = process.env.REDIRECT_SECRET_VALUE; // Get secret from environment variable

          if (!fs.existsSync(tenantYamlPath)) {
            console.error('Error: Source tenant.yaml not found at: ' + tenantYamlPath);
            process.exit(1);
          }
          if (!fs.existsSync(importConfigPath)) {
            console.error('Error: Import config (temp_import_config.json) not found.');
            process.exit(1);
          }

          let tenantYamlContent = fs.readFileSync(tenantYamlPath, 'utf8');
          const importConfig = JSON.parse(fs.readFileSync(importConfigPath, 'utf8'));
          const mappings = importConfig.AUTH0_KEYWORD_REPLACE_MAPPINGS || {};
          
          console.log('Applying the following keyword replacement mappings to tenant.yaml:');
          console.log(JSON.stringify(mappings, null, 2));

          const sortedMappingKeys = Object.keys(mappings).sort((a, b) => b.length - a.length);

          for (const sourceString of sortedMappingKeys) {
            if (mappings.hasOwnProperty(sourceString)) {
              const targetString = mappings[sourceString];
              // Escape special characters in the source string for use in RegExp
              const escapedSourceString = sourceString.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
              const regex = new RegExp(escapedSourceString, 'g');
              tenantYamlContent = tenantYamlContent.replace(regex, targetString);
            }
          }
          
          // --- Start of logic for injecting REDIRECT_SECRET ---
          let tenantConfig;
          try {
            tenantConfig = yaml.load(tenantYamlContent);
          } catch (e) {
            console.error("Error parsing tenant.yaml:", e);
            process.exit(1);
          }

          // Ensure 'actions' section exists
          if (!tenantConfig.actions) {
            tenantConfig.actions = [];
          }

          // Find the action named 'some name' or create it if it doesn't exist
          let someNameAction = tenantConfig.actions.find(action => action.name === 'some name');

          if (!someNameAction) {
            someNameAction = { name: 'some name', secrets: [] };
            tenantConfig.actions.push(someNameAction);
            console.log("Created 'some name' action as it did not exist.");
          }

          // Ensure 'secrets' array exists within the action
          if (!someNameAction.secrets) {
            someNameAction.secrets = [];
          }

          // Check if REDIRECT_SECRET already exists and update its value, otherwise add it
          const existingSecretIndex = someNameAction.secrets.findIndex(s => s.name === 'REDIRECT_SECRET');
          if (existingSecretIndex > -1) {
            someNameAction.secrets[existingSecretIndex].value = redirectSecret;
            console.log("Updated existing 'REDIRECT_SECRET' in 'some name' action.");
          } else {
            someNameAction.secrets.push({ name: 'REDIRECT_SECRET', value: redirectSecret });
            console.log("Added new 'REDIRECT_SECRET' to 'some name' action.");
          }

          tenantYamlContent = yaml.dump(tenantConfig); // Convert the modified JavaScript object back to YAML string
          // --- End of logic ---

          fs.writeFileSync(outputTransformedTenantYamlPath, tenantYamlContent, 'utf8');
          console.log('Transformed tenant.yaml preview saved to: ' + outputTransformedTenantYamlPath);
          NODE_SCRIPT_EOF

          # Execute the Node.js script from the file
          node transform_script.js
          NODE_EXIT_CODE=$?
          echo "Node.js script finished with exit code: $NODE_EXIT_CODE"
          
          rm transform_script.js # Clean up the temporary script file

          if [ $NODE_EXIT_CODE -ne 0 ]; then
            echo "Error: Node.js transformation script failed."
            exit $NODE_EXIT_CODE
          fi
        env:
          # Pass the generated secret as an environment variable to the Node.js script
          REDIRECT_SECRET_VALUE: ${{ steps.generate_redirect_secret.outputs.REDIRECT_SECRET }}

      - name: Archive Transformed tenant.yaml Preview
        uses: actions/upload-artifact@v4
        with:
          name: transformed-tenant-yaml-for-${{ github.event.inputs.target_environment }}
          path: ./transformed_tenant_preview.yaml
      
      - name: Dry Run Instructions
        run: |
          echo "DRY RUN COMPLETE. NO ACTUAL IMPORT PERFORMED."
          echo "Please download the following artifacts from this workflow run:"
          echo "1. 'original-export-from-${{ github.event.inputs.source_environment }}': Contains the full, unchanged configuration exported from the source tenant."
          echo "2. 'import-config-for-${{ github.event.inputs.target_environment }}': This is the 'temp_import_config.json' file with keyword mappings."
          echo "3. 'transformed-tenant-yaml-for-${{ github.event.inputs.target_environment }}': Contains 'transformed_tenant_preview.yaml', a preview of the main tenant file."
          echo ""
          echo "IMPORTANT: Review 'transformed_tenant_preview.yaml' carefully. Also, manually compare files in 'original-export-from-${{ github.event.inputs.source_environment }}' (like action scripts, page HTML) against the mappings in 'import-config-for-${{ github.event.inputs.target_environment }}' as their content is NOT transformed in this dry run preview file."
